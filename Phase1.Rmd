---
title: "Phase 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SimSurvey)
library(plotly)
```

# Simulate an age-structured, spatially-correlated population

`sim_distribution()` is used to distribute a population simulated using `sim_abundance()` throughout a grid. 

- Key arguments:

1. `sim` -- A list with abundance details like produced by `sim_abundance()`
  
  - `ages`, `years` -- supply vectors of ages and years to simulate across
  - `R`, `Z`, `N0`, `growth` -- supply closures such as `sim_R()`, `sim_Z()`, `sim_N0()` and `sim_vonB()`
  
2. `grid` -- A raster object defining the survey grid, like the one produced by `make_grid()` -- sets up a depth stratified survey grid, returns a raster object with four layers: `depth`, `cell`, `division`, and `strat`; Number of strata are affected by the number of divisions (`n_div`), horizontal splits (`strat_splits`), the depth gradient (`shelf_depth`, `shelf_width`, `depth_range`), and depth breaks (`strat_breaks`)

3. `ays_covar` -- Closure for simulating age-year-space covariance, like `sim_ays_covar()` -- covarience matrix
  
4. `depth_par` -- Closure for defining relationship between abundance and depth, like `sim_parabola()`

```{r}
set.seed(431)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:20, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.9, 
                               plot = TRUE),
                     R = sim_R(log_mean = log(1e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = TRUE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = TRUE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = TRUE,
                                       length_group = 3))  %>%
                                      
  sim_distribution(grid = make_grid(x_range = c(-140, 140), # km
                                    y_range = c(-140, 140), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #m
                                    shelf_width = 100, #km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.1),#weak correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70))

  
```


Some graphs:

```{r}
plot_trend(pop)
```

```{r}
plot_surface(pop)
```
```{r}
library(dplyr)
xy_sim <- as_tibble(pop$grid_xy)
df_sim <- as_tibble(pop$sp_N)
```


```{r}
df_sim <- left_join(df_sim, xy_sim, by = "cell")
df_sim$logdv <- log(df_sim$N/1e+07)

library(ggplot2)

# distribution of total N of all ages in a year in a cell
df_sim %>% 
  group_by(x, y, year, cell) %>% 
  summarise(N = sum(N), .groups = "drop") %>% 
ggplot(aes(x, y, fill = log(N + 1))) +
  geom_raster() +
    facet_wrap(~year) +
  scale_fill_viridis_c()

```


```{r}
# distribution of N of an age in a year in a cell (interactive plots with an Age-Year slider)

plot_distribution2 <-
function (sim, ages = 1:10, years = 1:10, type = "contour", 
    scale = "natural", ...) 
{
    age <- NULL
    xax <- list(title = "", zeroline = FALSE, showline = FALSE, showticklabels = FALSE, showgrid = FALSE, ticks = "")
    yax <- c(scaleanchor = "x", xax)
    d <- merge(sim$grid_xy, sim$sp_N[age %in% ages & year %in% years, ], by = "cell")
    if (scale == "log") 
        d$N <- log(d$N)
    
    d$ay <- paste(d$age, d$year, sep = "-")
    split_d <- split(d, d$ay)
    split_d <- lapply(split_d, function(.) {
        stats::xtabs(N ~ y + x, data = ., subset = NULL)
    })
    
    x <- sort(unique(d$x))
    y <- sort(unique(d$y))
    ay_combos <- expand.grid(age = sort(unique(d$age)), year = sort(unique(d$year)))
    ay_combos$ay <- paste(ay_combos$age, ay_combos$year, sep = "-")
    split_d <- split_d[ay_combos$ay]
    
    p <- plot_ly(x = ~x, y = ~y, ...)
          visible <- rep(TRUE, length(split_d))
          showscale <- rep(FALSE, length(split_d))
          showscale[1] <- TRUE
          steps <- list()
          
    for (i in seq_along(split_d)) {
        vis <- rep(FALSE, length(split_d))
        vis[i] <- TRUE
        p <- p %>% add_trace(type = type, 
                             z = matrix(split_d[[i]], 
                             nrow=nrow(split_d[[i]]), 
                             ncol=ncol(split_d[[i]])), 
                             visible = i == 1, 
                             showscale = vis, 
                             name = names(split_d)[i], 
                             colorbar = list(title = "N")) %>% 
            layout(xaxis = xax, yaxis = yax)
            steps[[i]] <- list(args = list(list(visible = vis, showscale = vis)), 
            method = "update", label = names(split_d)[i])
    }
    if (length(ages) > 1 | length(years) > 1) {
        p <- p %>% layout(sliders = list(list(currentvalue = list(prefix = "Age-Year: "), 
            steps = steps)))
    }
    p
}


plot_distribution2(pop, ages = 1:20, years = 1:20, type = "heatmap")

```

# Survey the Simulated population


`sim_survey()` function applies stratified random sampling of a survey with a catchability defined by a logistic curve [`sim_logistic()`].


```{r}
set.seed(34)
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 1, # number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = FALSE), # function of catchability at age (k=The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #	Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, # Allow resampling of sampling units?
  binom_error = TRUE, # Impose binomial error? 
  #min_sets = 2, # Minimum number of sets per strat
  set_den = 2/1000, #Set density (number of sets per [grid unit] squared).
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()

plot_survey(survey, which_year = 2, which_sim = 1) # plotting 1st set of 2nd year

```


# Fitting a geostatistical spatiotemporal model

sdmTMB is an R package for fast and flexible fitting of spatiotemporal species distribution GLMMs with TMB

- Modeling steps:

  1. **Make an R-INLA "mesh" representing spatial "knots"** - `make_mesh()`
  2. **Fit a spatiotemporal GLMM** - `sdmTMB()`
      - Implements a geostatistical model using TMB, R-INLA, and Gaussian Markov random fields
      - Function is set up similarly to `glm()`, `lmer()`, or `glmmTMB()`
  3. **Inspect the model** - `print()`, `tidy()`, `predict()`, `residuals()`, `sdmTMB_cv()`, `sdmTMB_sim()`, `AIC()`
  4. **Predict on a grid that represents the survey domain** - `predict()`
  5. **Calculate the survey index** - `get_index()`
      - Use `get_index()` to sum the expected density or abundance across the grid and calculate standard errors

```{r}
library(sdmTMB)
```


## Creating an SPDE (Stochastic partial differential equation) mesh object representing spatial "knots" via the INLA R package

The important part of this is coming up with a reasonable resolution of "knots" or representative locations that will be modeled. Values in between these knots will be interpolated with bilinear interpolation along the triangles. This approach greatly increases computational efficiency. Smaller `cutoff` values (in units x-y coordinate units), will generate more knots. More knots will generally make for a better approximation at the expense of fitting time. There are other possible meshes and you can use any mesh from INLA.

```{r}

## creating a data frame by including population survey grids
xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area


mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  #type = c("kmeans", "cutoff", "cutoff_search"), #Method to create the mesh, default=cutoff
  cutoff = 10, #The minimum allowed distance between points in the mesh, Smaller `cutoff` values (in units x-y coordinate units), will generate more knots
  #n_knots, #number of desired knots
  #seed = 42, #Random seed
  #refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),
  #mesh = NULL
)

plot(mesh)
```

## Fitting a model

- Key arguments:

-   `spatial = TRUE` means the model will include a separate spatial random field (a wiggly intercept surface that stays constant through time) and spatiotemporal fields (a random field that varies each year; default is `spatiotemporal = 'iid'`). There's also an option for correlated fields (`spatiotemporal = 'ar1'`).
-   `time = "year"` tells the function which column of data represents the time element and tells the model this is spatiotemporal, not just spatial, data.
-   `silent = FALSE` tells the function to print out TMB progress messages.
-   `offset` is a reserved word in sdmTMB and will be fit with its coefficient fixed at 1.
-   `0 + as.factor(year)` in the formula sets up the model matrix so that there is an independent mean for each year.
-   `mesh = mesh` tells it to use our mesh from above.

```{r}
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE)
#print(fit)
```

Let's look at residuals:

```{r}
dat$resid <- residuals(fit)

ggplot(dat, aes(x, y, colour = resid, size = abs(resid))) +
  geom_point() +
  facet_wrap(~year) +
  scale_colour_gradient2() +
  scale_size_area(max_size = 2)
```

Also see <https://pbs-assess.github.io/sdmTMB/articles/residual-checking.html> for other residual options. Simulated residuals are likely a better option here.


## Predicting over the survey domain and calculating an index of abundance

To calculate an index of abundance, first we need to create a grid that covers the entirety of our survey domain. 

```{r}
library(tidyverse)
grid_dat <- tidyr::expand_grid(x = sort(unique(df_sim$x)), y = sort(unique(df_sim$y)))
grid_dat <- purrr::map_dfr(sort(unique(dat$year)), ~ bind_cols(grid_dat, year = .))
grid_dat$offset <- mean(dat$offset)
```


Next we need to predict from our model onto our survey grid. `return_tmb_object = TRUE` tells the function to return a TMB object that is critical for calculating the survey index. If enabled, the result will be a list with the predictions as one element and the TMB object as another. If disabled, the result will just be a prediction data frame.

The `area` argument represents the area of a grid cell so that the resulting estimate is per m^2^ or km^2^. Here, that is 10 x 10 km. `area` can be a vector if some grid cells overlap land or are partially outside the survey domain.

```{r, eval=FALSE}
pred <- predict(fit, 
                newdata = grid_dat, 
                return_tmb_object = TRUE, #important for calculating the survey index
                area = 100)
index <- get_index(pred) #It sums up the abundance in all of the grid cells and calculates standard errors on the result
```

Perhaps a better option is to simulate from the joint parameter distribution and calculate the index with those. This achieves approximately the same result at `bias_correct = TRUE`, but is faster.

```{r}
pred <- predict(fit, 
                newdata = grid_dat, 
                sims = 1000)
index <- get_index_sims(pred, area = rep(100, nrow(pred))) # sums up the abundance in all of the grid cells and calculates standard errors on the result
```



# Combining Design-based and Model-based estimated indices with the "true" known population trajectory

```{r}
true_abund <- tibble(year = unique(df_sim$year), N = as.numeric(colSums(survey$I))) %>%
  mutate(type = "True")

strat_abund <- tibble::as_tibble(survey$total_strat) %>% 
  mutate(N = total, type = "Design-based") %>% 
  select(year, N, type)


both <- index %>%
  mutate(type = "Model-based", N = est) %>%
  bind_rows(true_abund) %>%
  bind_rows(strat_abund) %>% 
  group_by(type) %>%
  mutate(geo_mean = exp(mean(log(N), na.rm = TRUE)),
         lwr_scaled = lwr / geo_mean, N_scaled = N / geo_mean, upr_scaled = upr / geo_mean,
         type = factor(type, levels = c("True", "Design-based", "Model-based"))) %>% 
  arrange(type)
```

And make a plot of the result:

```{r, warning=FALSE}
ggplot(both, aes(year, N_scaled, group = type)) +
  geom_line(aes(colour = type, size = type)) +
  geom_ribbon(aes(ymin = lwr_scaled, ymax = upr_scaled, fill = type), alpha = 0.3) +
  labs(x = "Year", y = "Relative abundance", colour = "Type", fill = "Type", size = "Type") +
  scale_color_manual(values = c("Model-based" = "grey30", "Design-based" = "steelblue", "True" = "red")) +
  scale_fill_manual(values = c("Model-based" = "grey30", "Design-based" = "steelblue", "True" = "red")) +
  scale_size_manual(values = c("Model-based" = 0.5, "Design-based" = 0.5, "True" = 1))
```
