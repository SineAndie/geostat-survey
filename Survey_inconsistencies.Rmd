---
title: "Under survey Inconsistencies"
output:
  html_document:
    df_print: paged
---
The aim is to compare indices of population abundance from geostatistical model(sdmTMB) with design-based estimates for simulated spatially-correlated populations. 

1. First, let's Simulate a spatial, age-structured population with SimSurvey.

```{r, echo=FALSE}
library(tictoc)

library(SimSurvey)
library(plotly)
library(ggplot2)
theme_set(theme_minimal())
library(tidyverse)


set.seed(351)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:10, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.6, 
                               plot = FALSE),
                     R = sim_R(log_mean = log(3e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = FALSE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = FALSE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = FALSE,
                                       length_group = 3))  %>%
  sim_distribution(grid = make_grid(x_range = c(-150, 150), # km
                                    y_range = c(-150, 150), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #Approximate depth of the shelf in m
                                    shelf_width = 50, #Approximate width of the shelf in km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix, higher value higher spatial correlation
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.1),# medium correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70, plot=FALSE))
```

2. Applying stratified random sampling of a survey with a catchability defined by a logistic curve.

```{r, echo=FALSE}
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 1, #number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = FALSE), #function of catchability at age (k= The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, #Allow resampling of sampling units?
  binom_error = TRUE, #Impose binomial error? 
  #min_sets = 2, #Minimum number of sets per strat
  set_den = 2/1000, #set per strata ~ strata area with a set density rule, sample size = sum(set numbers per strat) * years 
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()%>% 
  SimSurvey::strat_error()
```

```{r}
#dropping some survey years
survey_year <- survey$setdet[!(survey$setdet$year %in% c(3,5)),]


#Stratified analysis after dropping years
survey_year_s <- survey
survey_year_s$setdet <- survey_year_s$setdet[!(survey$setdet$year %in% c(3,5)),]
survey_year_strat<- survey_year_s %>% run_strat()

dim(survey$setdet)
dim(survey_year_strat$setdet)
dim(survey$total_strat)
dim(survey_year_strat$total_strat)
```

```{r, echo=FALSE}
#dropping some strata according to the depth (keep only strata with a depth lower than 500) #dropping an area

length(unique(survey_year$strat)) # we have 30 strata 

survey_depth <- survey$setdet[which(survey$setdet$depth <= 500),]

length(unique(survey_depth$strat)) # we have 24 strata 

```

```{r}
#dropping some random strata (30 total strata, dropping 3 of them (%10))

#set.seed(1)
#sample(1:30, 3, replace=F)

survey_strata <- survey$setdet[!(survey$setdet$strat %in% c(25,4,7)),]

```

3. Fitting a geostatistical spatiotemporal model

3.1. Creating a data frame by including population survey grids

```{r}
xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_year <- as_tibble(survey_year) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_depth <- as_tibble(survey_depth) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_strata <- as_tibble(survey_strata) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area
```

3.2. Creating a mesh

```{r}
mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_year <- sdmTMB::make_mesh(
  dat_year, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_depth <- sdmTMB::make_mesh(
  dat_depth, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_strata <- sdmTMB::make_mesh(
  dat_strata, 
  xy_cols = c("x", "y"),
  cutoff = 10)

```

3.3. Fitting the models

```{r, echo=TRUE}

library(sdmTMB)

tic()
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

tic()
fit_year <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_year,
              mesh = mesh_year,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()


tic()
fit_depth <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_depth,
              mesh = mesh_depth,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

tic()
fit_strata <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_strata,
              mesh = mesh_strata,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

```

3.4. Using simulation-based approach for residuals checks

```{r}
#Converting simulated residuals to a DHARMa object

sim_fit <- simulate(fit, nsim = 500) 
fit_dharma <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) 
)

sim_fit_year <- simulate(fit_year, nsim = 500) 
fit_dharma_year <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_year,
  observedResponse = dat_year$N, 
  fittedPredictedResponse = fit_year$family$linkinv(predict(fit_year)$est_non_rf) 
)

sim_fit_depth <- simulate(fit_depth, nsim = 500)
fit_dharma_depth <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_depth,
  observedResponse = dat_depth$N, 
  fittedPredictedResponse = fit_depth$family$linkinv(predict(fit_depth)$est_non_rf) 
)

sim_fit_strata <- simulate(fit_strata, nsim = 500)
fit_dharma_strata <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_strata,
  observedResponse = dat_strata$N, 
  fittedPredictedResponse = fit_strata$family$linkinv(predict(fit_strata)$est_non_rf) 
)
```

```{r, echo = TRUE, eval = TRUE}
#Testing whether fitted models are consistent with the observed number of zeros

sum(dat$N == 0) / length(dat$N)
sum(sim_fit == 0)/length(sim_fit)

sum(dat_year$N == 0) / length(dat_year$N)
sum(sim_fit_year == 0)/length(sim_fit_year)

sum(dat_depth$N == 0) / length(dat_depth$N)
sum(sim_fit_depth == 0)/length(sim_fit_depth)

sum(dat_strata$N == 0) / length(dat_strata$N)
sum(sim_fit_strata == 0)/length(sim_fit_strata)
```

```{r}
DHARMa::testResiduals(fit_dharma) # testUniformity and the testDispersion 
plot(fit_dharma)
```

```{r}
DHARMa::testResiduals(fit_dharma_year)
plot(fit_dharma_year)
```

```{r}
DHARMa::testResiduals(fit_dharma_depth)
plot(fit_dharma_depth)
```

```{r}
DHARMa::testResiduals(fit_dharma_strata)
plot(fit_dharma_strata)
```

4. Predicting over the survey domain and calculating an index of abundance

4.1 To calculate an index of abundance, first we need to create a grid that covers the entirety of our survey domain. 

```{r}
library(tidyverse)
grid_dat <- as_tibble(select(survey$grid_xy, x, y, depth)) %>% distinct()
grid_dat <- purrr::map_dfr(sort(unique(dat$year)), ~ bind_cols(grid_dat, year = .))
grid_dat$offset <- mean(dat$offset)
grid_dat$area <-survey$setdet$cell_area[1]/survey$setdet$tow_area[1]

grid_dat_depth <- as_tibble(select(survey_depth, x, y, depth)) %>% distinct()
grid_dat_depth <- purrr::map_dfr(sort(unique(dat_depth$year)), ~ bind_cols(grid_dat_depth, year = .))
grid_dat_depth$offset <- mean(dat_depth$offset)
grid_dat_depth$area <- survey_depth$cell_area[1]/survey_depth$tow_area[1]

grid_dat_year <- as_tibble(select(survey_year, x, y, depth)) %>% distinct()
grid_dat_year <- purrr::map_dfr(sort(unique(dat_year$year)), ~ bind_cols(grid_dat_year, year = .))
grid_dat_year$offset <- mean(dat_year$offset)
grid_dat_year$area <- survey_year$cell_area[1]/survey_year$tow_area[1]

grid_dat_strata <- as_tibble(select(survey_strata, x, y, depth)) %>% distinct()
grid_dat_strata <- purrr::map_dfr(sort(unique(dat_strata$year)), ~ bind_cols(grid_dat_strata, year = .))
grid_dat_strata$offset <- mean(dat_strata$offset)
grid_dat_strata$area <- survey_strata$cell_area[1]/survey_strata$tow_area[1]
```

4.2 Prediction

```{r}
pred <- predict(fit, 
                newdata = grid_dat, 
                return_tmb_object = TRUE, 
                area = grid_dat$area) 

pred_depth <- predict(fit_depth, 
                newdata = grid_dat_depth, 
                return_tmb_object = TRUE, 
                area = grid_dat_depth$area) 

pred_year <- predict(fit_year, 
                newdata = grid_dat_year, 
                return_tmb_object = TRUE, 
                area = grid_dat_year$area) 

pred_strata <- predict(fit_strata, 
                newdata = grid_dat_strata, 
                return_tmb_object = TRUE,
                area = grid_dat_strata$area)
```

4.3. Summing up the abundance in all of the grid cells and calculates standard errors on the result

```{r}
index <- get_index(pred)
index_depth <- get_index(pred_depth)
index_year <- get_index(pred_year)
index_strata <- get_index(pred_strata)
```

5. Combining Design-based and Model-based estimated indices with the "true" known population trajectory

```{r}
true_abund <- tibble(year = unique(dat$year), N = as.numeric(colSums(survey$I))) %>%
  mutate(type = "True")

strat_abund <- tibble::as_tibble(survey$total_strat) %>% 
  mutate(N = total, type = "Design-based") %>% 
  select(year, N, type)

strat_year_abundance <-tibble::as_tibble(survey_year_strat$total_strat) %>% 
  mutate(N = total, type = "Design-based after dropping years") %>% 
  select(year, N, type)

indexc <- index %>%
  mutate(type = "Model-based", N = est) %>%
  bind_rows(true_abund) %>%
  bind_rows(strat_abund)

indexc_year <- index_year %>%
  mutate(type = "MB 2 years dropped", N = est) %>%
  bind_rows(true_abund) %>%
  bind_rows(strat_year_abundance)
```


```{r}

indexc %>% 
  plot_ly(x = ~year, color = ~type, legendgroup = ~type) %>% 
  add_ribbons(ymin = ~lwr, ymax = ~upr, line = list(width = 0), showlegend = FALSE) %>% 
  add_lines(y = ~N)


```

```{r}

indexc_year %>% 
  plot_ly(x = ~year, color = ~type, legendgroup = ~type) %>% 
  add_ribbons(ymin = ~lwr, ymax = ~upr, line = list(width = 0), showlegend = FALSE) %>% 
  add_lines(y = ~N)

```






















