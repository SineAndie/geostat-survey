---
title: "Under survey Inconsistencies"
output:
  html_document:
    df_print: paged
---
The aim is to compare indices of population abundance from geostatistical model(sdmTMB) with design-based estimates for simulated spatially-correlated populations. 

1. First, let's Simulate a spatial, age-structured population with SimSurvey.

```{r, echo=FALSE}
library(tictoc)

library(SimSurvey)
library(plotly)
library(ggplot2)
theme_set(theme_minimal())
library(tidyverse)


set.seed(351)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:20, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.6, 
                               plot = FALSE),
                     R = sim_R(log_mean = log(3e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = FALSE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = FALSE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = FALSE,
                                       length_group = 3))  %>%
  sim_distribution(grid = make_grid(x_range = c(-150, 150), # km
                                    y_range = c(-150, 150), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #Approximate depth of the shelf in m
                                    shelf_width = 50, #Approximate width of the shelf in km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix, higher value higher spatial correlation
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.1),# medium correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70, plot=FALSE))
```

2. Applying stratified random sampling of a survey with a catchability defined by a logistic curve.

```{r, echo=FALSE}
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 1, #number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = FALSE), #function of catchability at age (k= The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, #Allow resampling of sampling units?
  binom_error = TRUE, #Impose binomial error? 
  #min_sets = 2, #Minimum number of sets per strat
  set_den = 2/1000, #set per strata ~ strata area with a set density rule, sample size = sum(set numbers per strat) * years 
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()
```

```{r}
#dropping some survey years

survey_year <- survey$setdet[!(survey$setdet$year %in% c(3,5,13)),]

```

```{r, echo=FALSE}
#dropping some strata according to the depth (keep only strata with a depth lower than 500) #dropping an area

length(unique(survey_year$strat)) # we have 30 strata 

survey_depth <- survey$setdet[which(survey$setdet$depth <= 500),]

length(unique(survey_depth$strat)) # we have 24 strata 

```
```{r}
#dropping some random strata (30 total strata, dropping 3 of them (%10))

#set.seed(1)
#sample(1:30, 3, replace=F)

survey_strata <- survey$setdet[!(survey$setdet$strat %in% c(25,4,7)),]

```

3. Fitting a geostatistical spatiotemporal model

3.1. Creating a data frame by including population survey grids

```{r}
xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_year <- as_tibble(survey_year) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_depth <- as_tibble(survey_depth) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

dat_strata <- as_tibble(survey_strata) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area
```

3.2. Creating a mesh

```{r}
mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_year <- sdmTMB::make_mesh(
  dat_year, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_depth <- sdmTMB::make_mesh(
  dat_depth, 
  xy_cols = c("x", "y"),
  cutoff = 10)

mesh_strata <- sdmTMB::make_mesh(
  dat_strata, 
  xy_cols = c("x", "y"),
  cutoff = 10)

```

3.3. Fitting the models

```{r, echo=TRUE}

library(sdmTMB)

tic()
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

tic()
fit_year <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_year,
              mesh = mesh_year,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()


tic()
fit_depth <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_depth,
              mesh = mesh_depth,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

tic()
fit_strata <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat_strata,
              mesh = mesh_strata,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()

```

3.4. Using simulation-based approach for residuals checks

```{r}
#Converting simulated residuals to a DHARMa object

sim_fit <- simulate(fit, nsim = 1000) 
fit_dharma <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) 
)

sim_fit_year <- simulate(fit_year, nsim = 1000) 
fit_dharma_year <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_year,
  observedResponse = dat_year$N, 
  fittedPredictedResponse = fit_year$family$linkinv(predict(fit_year)$est_non_rf) 
)

sim_fit_depth <- simulate(fit_depth, nsim = 1000)
fit_dharma_depth <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_depth,
  observedResponse = dat_depth$N, 
  fittedPredictedResponse = fit_depth$family$linkinv(predict(fit_depth)$est_non_rf) 
)

sim_fit_strata <- simulate(fit_strata, nsim = 1000)
fit_dharma_strata <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit_strata,
  observedResponse = dat_strata$N, 
  fittedPredictedResponse = fit_strata$family$linkinv(predict(fit_strata)$est_non_rf) 
)
```

```{r, echo = TRUE, eval = TRUE}
#Testing whether fitted models are consistent with the observed number of zeros

sum(dat$N == 0) / length(dat$N)
sum(sim_fit == 0)/length(sim_fit)

sum(dat_year$N == 0) / length(dat_year$N)
sum(sim_fit_year == 0)/length(sim_fit_year)

sum(dat_depth$N == 0) / length(dat_depth$N)
sum(sim_fit_depth == 0)/length(sim_fit_depth)

sum(dat_strata$N == 0) / length(dat_strata$N)
sum(sim_fit_strata == 0)/length(sim_fit_strata)
```

```{r}
# N ~ 0 + as.factor(year) + offset, spatiotemporal = c("IID"))
DHARMa::testResiduals(fit_dharma) # testUniformity and the testDispersion 
plot(fit_dharma)
```
```{r}

DHARMa::testResiduals(fit_dharma_year)
plot(fit_dharma_year)
```

```{r}

DHARMa::testResiduals(fit_dharma_depth)
plot(fit_dharma_depth)

```

```{r}

DHARMa::testResiduals(fit_dharma_strata)
plot(fit_dharma_strata)

```




























