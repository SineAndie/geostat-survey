---
title: "Under survey Inconsistencies"
output: html_notebook
---


The aim is to compare indices of population abundance from geostatistical model(sdmTMB) with design-based estimates for simulated spatially-correlated populations. 

1. First, let's Simulate a spatial, age-structured population with SimSurvey. It has two sections: modeling a population by using an exponential decay cohort model and distributing this population over an area through space and add spatial-temporal noise. 

```{r}
library(SimSurvey)
library(plotly)
library(ggplot2)
theme_set(theme_minimal())
library(tidyverse)


set.seed(351)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:20, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.6, 
                               plot = FALSE),
                     R = sim_R(log_mean = log(3e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = FALSE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = FALSE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = FALSE,
                                       length_group = 3))  %>%
  sim_distribution(grid = make_grid(x_range = c(-150, 150), # km
                                    y_range = c(-150, 150), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #Approximate depth of the shelf in m
                                    shelf_width = 50, #Approximate width of the shelf in km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix, higher value higher spatial correlation
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.1),# medium correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70, plot=FALSE))
```


2. Applying stratified random sampling of a survey with a catchability defined by a logistic curve.

```{r}
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 1, # number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = TRUE), # function of catchability at age (k= The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #	Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, # Allow resampling of sampling units?
  binom_error = TRUE, # Impose binomial error? 
  #min_sets = 2, # Minimum number of sets per strat
  set_den = 2/1000, ##set per strata ~ strata area with a set density rule, sample size = sum(set numbers per strat) * years 
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()
```


3. Fitting a geostatistical spatiotemporal model

3.1. Creating a data frame by including population survey grids

```{r}
xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area
```

3.2. Creating a mesh

```{r}

mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  #type = c("kmeans", "cutoff", "cutoff_search"), #Method to create the mesh, default=cutoff
  cutoff = 9, #The minimum allowed distance between points in the mesh, Smaller `cutoff` values (in units x-y coordinate units), will generate more knots
  #n_knots, #number of desired knots
  #seed = 42, #Random seed
  #refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),
  #mesh = NULL
)
```

3.3. Fitting the model

```{r}
library(tictoc)
library(sdmTMB)

tic()
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()
```


3.4. Checking residuals

```{r}
dat$resid <- residuals(fit)
qqnorm(dat$resid)
abline(a = 0, b = 1)
```
3.5. Using simulation-based approach for residuals checks

- Converting simulated residuals to a DHARMa object

To create a DHARMa object, we need simulated response vectors, observed data, and predicted response from the model.

```{r}

fit_dharma <- DHARMa::createDHARMa(
  simulatedResponse =  simulate(fit, nsim = 1000),
  observedResponse = dat$N, # true observations
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) # predicted response
)


# simulate from the model
sim_fit =  simulate(fit, nsim = 1000)

#test whether fitted models are consistent with the observed number of zeros
sum(dat$N == 0) / length(dat$N)
sum(sim_fit == 0)/length(sim_fit)

```

- DHARMA plots

```{r}

plot(fit_dharma)

DHARMa::testResiduals(fit_dharma)

DHARMa::testZeroInflation(fit_dharma)

#DHARMa::testSpatialAutocorrelation(fit_dharma, x = dat$x, y = dat$y)
#DHARMa::testTemporalAutocorrelation(fit_dharma, time = dat$year)

DHARMa::plotResiduals(fit_dharma, form = dat$depth)

DHARMa::testOutliers(fit_dharma, type = c("binomial"), nBoot = 100, plot = T)

DHARMa::testUniformity(simulationOutput = fit_dharma)


```


































