---
title: "Testing different model setups"
output:
  html_document:
    df_print: paged
---
1.  Simulating an age-structured, spatially-correlated population
```{r}
library(tictoc)

library(SimSurvey)
library(plotly)
library(ggplot2)
theme_set(theme_minimal())

library(tidyverse)
library(sdmTMB)
library(DHARMa)

set.seed(351)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:20, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.6, 
                               plot = FALSE),
                     R = sim_R(log_mean = log(3e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = FALSE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = FALSE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = FALSE,
                                       length_group = 3))  %>%
  sim_distribution(grid = make_grid(x_range = c(-150, 150), # km
                                    y_range = c(-150, 150), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #Approximate depth of the shelf in m
                                    shelf_width = 50, #Approximate width of the shelf in km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix, higher value higher spatial correlation
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.1),# medium correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70, plot=FALSE)) 
```

2. Applying stratified random sampling of a survey with a catchability defined by a logistic curve.

```{r}
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 3, #number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = FALSE), #function of catchability at age (k= The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, #Allow resampling of sampling units?
  binom_error = TRUE, #Impose binomial error? 
  #min_sets = 2, #Minimum number of sets per strat
  set_den = 2/1000, #set per strata ~ strata area with a set density rule, sample size = sum(set numbers per strat) * years 
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()
```

3. Fitting a geostatistical spatiotemporal model

   3.1. Creating a data frame by including population survey grids

```{r}
xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area
```

   3.2. Creating a mesh with different cutoff values

```{r}
mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  #type = c("kmeans", "cutoff", "cutoff_search"), #Method to create the mesh, default=cutoff
  cutoff = 10, #The minimum allowed distance between points in the mesh, Smaller `cutoff` values (in units x-y coordinate units), will generate more knots
  #n_knots, #number of desired knots
  #seed = 42, #Random seed
  #refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),
  #mesh = NULL
)

mesh2 <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  #type = c("kmeans", "cutoff", "cutoff_search"), #Method to create the mesh, default=cutoff
  cutoff = 8, #The minimum allowed distance between points in the mesh, Smaller `cutoff` values (in units x-y coordinate units), will generate more knots
  #n_knots, #number of desired knots
  #seed = 42, #Random seed
  #refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),
  #mesh = NULL
)
```

   3.3. Fitting the models

```{r}
tic()
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()
print(fit)


tic()
fit2 <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("AR1"))
toc()
print(fit2)

tic()
fit3 <- sdmTMB(N ~ 0 + as.factor(year) + offset + s(depth),
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()
print(fit3)

tic()
fit4 <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh2,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))
toc()
print(fit4)
```

   3.4. Using simulation-based approach for residuals checks

```{r}
#Converting simulated residuals to a DHARMa object

sim_fit <- simulate(fit, nsim = 1000)
fit_dharma <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) 
)

sim_fit1 <- simulate(fit, nsim = 500)
fit_dharma1 <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) 
)

sim_fit2 <- simulate(fit2, nsim = 1000) 
fit_dharma2 <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit2,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit2$family$linkinv(predict(fit2)$est_non_rf) 
)
sim_fit3 <- simulate(fit3, nsim = 1000)
fit_dharma3 <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit3,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit3$family$linkinv(predict(fit3)$est_non_rf) 
)

sim_fit4 <- simulate(fit4, nsim = 1000)
fit_dharma4 <- DHARMa::createDHARMa(
  simulatedResponse =  sim_fit4,
  observedResponse = dat$N, 
  fittedPredictedResponse = fit4$family$linkinv(predict(fit4)$est_non_rf) 
)
```

```{r, echo = TRUE}
#Testing whether fitted models are consistent with the observed number of zeros

sum(dat$N == 0) / length(dat$N)

sum(sim_fit == 0)/length(sim_fit)

sum(sim_fit1 == 0)/length(sim_fit1)

sum(sim_fit2 == 0)/length(sim_fit2)

sum(sim_fit3 == 0)/length(sim_fit3)

sum(sim_fit4 == 0)/length(sim_fit4)
```

```{r}
# N ~ 0 + as.factor(year) + offset, spatiotemporal = c("IID"))
DHARMa::testResiduals(fit_dharma) # testUniformity and the testDispersion 
plot(fit_dharma)
```

```{r}
# N ~ 0 + as.factor(year) + offset, spatiotemporal = c("IID")) --- nsim 500
DHARMa::testResiduals(fit_dharma1) # testUniformity and the testDispersion 
plot(fit_dharma1)
```

```{r}
# N ~ 0 + as.factor(year) + offset, spatiotemporal = c("AR1"))
DHARMa::testResiduals(fit_dharma2)
plot(fit_dharma2)
```

```{r}
# N ~ 0 + as.factor(year) + offset + s(depth), spatiotemporal = c("IID"))
DHARMa::testResiduals(fit_dharma3)
plot(fit_dharma3)
```

```{r}
# N ~ 0 + as.factor(year) + offset, spatiotemporal = c("IID")) --- mesh, cutoff 8
DHARMa::testResiduals(fit_dharma4) # testUniformity and the testDispersion 
plot(fit_dharma4)
```
