---
title: "Introduction to SimSurvey and sdmTMB"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(SimSurvey)
library(plotly)
library(ggplot2)
```

# Simulate an age-structured, spatially-correlated population

SimSurvey uses the exponential decay cohort model,

$$N_{a,y}=N_{a-1,y-1}exp(-Z_{a-1,y-1})$$ in which abundance at age a in year y is equal to that cohort abundance in the previous year times the survival rate, which is expressed in terms of the total mortality rate (Z). 

First year filled via exponential decay $N_{a,1} = N_{a-1,1} e^{-Z_{a-1,1}}$. 

Numbers_at_age 1 (i.e. recruits) vary around a baseline value, $log(N_{1,y}) = log(μ_r) + ϵ_y$, where the error around the recruitment process was set to follow a random walk,$ ϵ_y \sim N(ϵ_{y-1},\sigma^2_r)$ or uncorrelated recruitment values. 

Total mortality correlated across ages and years $log(Z_{a,y}) = log(\mu_Z) + \delta_{a,y}$, where $\delta_{a,y} \sim N(0, \Sigma_{a,y})$, Using covariance $\Sigma_{a,y}$


After similating the an age-structured population, `sim_distribution()` is used to distribute a population simulated using `sim_abundance()` throughout a grid. 

Distribute population through space and add spatial-temporal noise:
    - $log(N_{a,y,s}) = log(N_{a,y}) + \eta_{a,y,s}$
    - $\eta_{a,y,s}$ includes parabolic relationship with depth and covariance between ages, years and space
        - $\eta_{a,y,s} = \frac{(d_s - \mu_{d}) ^ 2}{2 \sigma_d^2} + \xi_{a,y,s}$
        - $\xi_{a,y,s}$ is a combination of Matérn covariance and the age-year covariance described in Cadigan 2016.

- Key arguments of `sim_distribution()`:

1. `sim` -- A list with abundance details like produced by `sim_abundance()`
  - `ages`, `years` -- supply vectors of ages and years to simulate across
  - `R`, `Z`, `N0`, `growth` -- supply closures such as `sim_R()`, `sim_Z()`, `sim_N0()` and `sim_vonB()`
  
2. `grid` -- A raster object defining the survey grid, like the one produced by `make_grid()` -- sets up a depth stratified survey grid, returns a raster object with four layers: `depth`, `cell`, `division`, and `strat`; Number of strata are affected by the number of divisions (`n_div`), horizontal splits (`strat_splits`), the depth gradient (`shelf_depth`, `shelf_width`, `depth_range`), and depth breaks (`strat_breaks`)

3. `ays_covar` -- Closure for simulating age-year-space covariance, like `sim_ays_covar()` -- covarience matrix
  
4. `depth_par` -- Closure for defining relationship between abundance and depth, like `sim_parabola()`

```{r}
set.seed(351)
pop <- sim_abundance(ages = 1:20, #fish age vector
                     years = 1:20, #year vector
                     Z = sim_Z(log_mean = log(0.6), #Total mortality matrix -- rnorm
                               log_sd = 0.1,
                               phi_age = 0.9,
                               phi_year = 0.6, 
                               plot = TRUE),
                     R = sim_R(log_mean = log(3e+07), #Recruitment vector -- rnorm
                               log_sd = 0.5,
                               random_walk = TRUE, 
                               plot = TRUE),
                     N0 = sim_N0(N0 = "exp", #Starting abundance vector -- exponential Z; N0 at age 1 is R0
                                 plot = TRUE), 
                     growth = sim_vonB(Linf = 100, #abundance-at-age matrix
                                       L0 = 5, 
                                       K = 0.2, 
                                       log_sd = 0.05, 
                                       plot = TRUE,
                                       length_group = 3))  %>%
  sim_distribution(grid = make_grid(x_range = c(-140, 140), # km
                                    y_range = c(-140, 140), # km
                                    res = c(10, 10), # km 
                                    shelf_depth = 200, #Approximate depth of the shelf in m
                                    shelf_width = 50, #Approximate width of the shelf in km
                                    depth_range = c(10, 1000), #m
                                    n_div = 1, #number of division
                                    strat_breaks = seq(0, 1000, by = 40), #strata depth breaks, meter
                                    strat_splits = 2, # horizontally split strat
                                    method = "spline"), #spline, loess, linear interpolation options
                   ays_covar = sim_ays_covar(range = 300, #adding noise correlated across space, year, and age dimensions -- covariance matrix, higher value higher spatial correlation
                                             phi_age = 0.8, #strong correlation across ages
                                             phi_year = 0.5),#weak correlation across years
                   depth_par = sim_parabola(mu = 200, #defining relationship between abundance and depth, i.e., adding a parabolic depth 'preference', fish prefers occurring around 200 meters 
                                            sigma = 70, plot=TRUE))


```

```{r}
#Species depth preference
  y <- sim_parabola(mu = 200, sigma = 70,)(x = 10:1000)
  depth_Pcurve <- data.frame(x = 10:1000, y)
  plot(depth_Pcurve)
  
```
Some graphs:
```{r}
plot_trend(pop)
```

```{r}
plot_surface(pop)
```

```{r}
library(dplyr)
xy_sim <- as_tibble(pop$grid_xy)
df_sim <- as_tibble(pop$sp_N)
```
```{r}
df_sim <- left_join(df_sim, xy_sim, by = "cell")

# distribution of total N of all ages in a year in a cell
df_sim %>% 
  group_by(x, y, year, cell) %>% 
  summarise(N = sum(N), .groups = "drop") %>% 
ggplot(aes(x, y, fill = log(N + 1))) +
  geom_raster() +
    facet_wrap(~year) +
  scale_fill_viridis_c()

```

The plot of the distribution of N of an age in a year in a cell (interactive plots with an Age-Year slider)

```{r}
# 

plot_distribution2 <-
function (sim, ages = 1:10, years = 1:10, type = "contour", 
    scale = "natural", ...) 
{
    age <- NULL
    xax <- list(title = "", zeroline = FALSE, showline = FALSE, showticklabels = FALSE, showgrid = FALSE, ticks = "")
    yax <- c(scaleanchor = "x", xax)
    d <- merge(sim$grid_xy, sim$sp_N[age %in% ages & year %in% years, ], by = "cell")
    if (scale == "log") 
        d$N <- log(d$N)
    
    d$ay <- paste(d$age, d$year, sep = "-")
    split_d <- split(d, d$ay)
    split_d <- lapply(split_d, function(.) {
        stats::xtabs(N ~ y + x, data = ., subset = NULL)
    })
    
    x <- sort(unique(d$x))
    y <- sort(unique(d$y))
    ay_combos <- expand.grid(age = sort(unique(d$age)), year = sort(unique(d$year)))
    ay_combos$ay <- paste(ay_combos$age, ay_combos$year, sep = "-")
    split_d <- split_d[ay_combos$ay]
    
    p <- plot_ly(x = ~x, y = ~y, ...)
          visible <- rep(TRUE, length(split_d))
          showscale <- rep(FALSE, length(split_d))
          showscale[1] <- TRUE
          steps <- list()
          
    for (i in seq_along(split_d)) {
        vis <- rep(FALSE, length(split_d))
        vis[i] <- TRUE
        p <- p %>% add_trace(type = type, 
                             z = matrix(split_d[[i]], 
                             nrow=nrow(split_d[[i]]), 
                             ncol=ncol(split_d[[i]])), 
                             visible = i == 1, 
                             showscale = vis, 
                             name = names(split_d)[i], 
                             colorbar = list(title = "N")) %>% 
            layout(xaxis = xax, yaxis = yax)
            steps[[i]] <- list(args = list(list(visible = vis, showscale = vis)), 
            method = "update", label = names(split_d)[i])
    }
    if (length(ages) > 1 | length(years) > 1) {
        p <- p %>% layout(sliders = list(list(currentvalue = list(prefix = "Age-Year: "), 
            steps = steps)))
    }
    p
}


plot_distribution2(pop, ages = 1:20, years = 1:20, type = "heatmap")

```

# Survey the Simulated population

`sim_survey()` function applies stratified random sampling of a survey with a catchability defined by a logistic curve [`sim_logistic()`].

```{r}
survey <- sim_survey(
  pop, #sim_distribution
  n_sims = 1, # number of survey
  q = sim_logistic(k = 2, x0 = 3, plot = TRUE), # function of catchability at age (k= The steepness of the curve, x0= x-value of the sigmoid's midpoint, curve max value=1)
  #trawl_dim = c(1.5, 0.02), #	Trawl width and distance (default=same units as grid)
  #resample_cells = FALSE, # Allow resampling of sampling units?
  binom_error = TRUE, # Impose binomial error? 
  #min_sets = 2, # Minimum number of sets per strat
  set_den = 2/1000, ##set per strata ~ strata area with a set density rule, sample size = sum(set numbers per strat) * years 
  #lengths_cap = 500, #Maximum number of lengths measured per set
  #ages_cap = 10,
  #age_sampling = "stratified",
  #age_length_group = 1,
  #age_space_group = "division",
  #light = TRUE
) %>% 
  SimSurvey::run_strat()

plot_survey(survey, which_year = 2, which_sim = 1) # plotting 1st set of 2nd year

```

# Fitting a geostatistical spatiotemporal model

sdmTMB is an R package for fast and flexible fitting of spatiotemporal species distribution GLMMs with TMB

- Modeling steps:

  1. **Make an R-INLA "mesh" representing spatial "knots"** - `make_mesh()`
  2. **Fit a spatiotemporal GLMM** - `sdmTMB()`
      - Implements a geostatistical model using TMB, R-INLA, and Gaussian Markov random fields
      - Function is set up similarly to `glm()`, `lmer()`, or `glmmTMB()`
  3. **Inspect the model** - `print()`, `tidy()`, `predict()`, `residuals()`, `sdmTMB_cv()`, `sdmTMB_sim()`, `AIC()`
  4. **Predict on a grid that represents the survey domain** - `predict()`
  5. **Calculate the survey index** - `get_index()`
      - Use `get_index()` to sum the expected density or abundance across the grid and calculate standard errors

```{r}
library(sdmTMB)
```

## Creating an SPDE (Stochastic partial differential equation) mesh object representing spatial "knots" via the INLA R package

The important part of this is coming up with a reasonable resolution of "knots" or representative locations that will be modeled. Values in between these knots will be interpolated with bilinear interpolation along the triangles. This approach greatly increases computational efficiency. Smaller `cutoff` values (in units x-y coordinate units), will generate more knots. More knots will generally make for a better approximation at the expense of fitting time. There are other possible meshes and you can use any mesh from INLA.

```{r}

## creating a data frame by including population survey grids

## setdet$n <- stats::rbinom(rep(1, nrow(setdet)), size = round(setdet$N/setdet$cell_sets), prob = (setdet$tow_area/setdet$cell_area) * q(setdet$age))


xy <- as_tibble(survey$grid_xy)
dat <- as_tibble(survey$setdet) %>%
  select(x, y, set, year, N = n, tow_area) %>%
  left_join(., xy, by = c("x", "y")) %>%
  mutate(offset = log(tow_area)) #setting up an "offset" variable to represent the tow area

## creating a mesh
mesh <- sdmTMB::make_mesh(
  dat, 
  xy_cols = c("x", "y"),
  #type = c("kmeans", "cutoff", "cutoff_search"), #Method to create the mesh, default=cutoff
  cutoff = 10, #The minimum allowed distance between points in the mesh, Smaller `cutoff` values (in units x-y coordinate units), will generate more knots
  #n_knots, #number of desired knots
  #seed = 42, #Random seed
  #refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),
  #mesh = NULL
)

plot(mesh$mesh)
```

## Fitting a model

- Key arguments:
-   `0 + as.factor(year)` in the formula sets up the model matrix so that there is an independent mean for each year.
-   `offset` is a reserved word in sdmTMB and will be fit with its coefficient fixed at 1.
-   `mesh = mesh` tells it to use our mesh from above.
-   `time = "year"` tells the function which column of data represents the time element and tells the model this is spatiotemporal, not just spatial data.
-   `spatial = TRUE` means the model will include a separate spatial random field (a wiggly intercept surface that stays constant through time)  parameter as: zeta_s
-   `spatiotemporal = TRUE` includes a random field that varied each year. The default is `spatiotemporal = 'iid'`.parameter as: epsilon_st

```{r}
fit <- sdmTMB(N ~ 0 + as.factor(year) + offset,
              data = dat,
              mesh = mesh,
              time = "year",
              family = nbinom2(link = "log"), 
              spatial = TRUE,
              spatiotemporal = c("IID"))

print(fit) #summary of the fit

tidy(fit, conf.int = TRUE)

tidy(fit, effects = "ran_pars", conf.int = TRUE)
#`omega_s` represents the simulated spatial random effects (only if present).


```

### Residuals
```{r}
dat$resid <- residuals(fit)

ggplot(dat, aes(x, y, colour = resid, size = abs(resid))) +
  geom_point() +
  facet_wrap(~year) +
  scale_colour_gradient2() +
  scale_size_area(max_size = 2)
```
```{r}
qqnorm(dat$resid)
abline(a = 0, b = 1)
```

### simulation-based approach for residuals checks

See more: <https://pbs-assess.github.io/sdmTMB/articles/residual-checking.html>.

- Converting simulated residuals to a DHARMa object

To create a DHARMa object, we need simulated response vectors, observed data, and predicted response from the model.

```{r}

fit_dharma <- DHARMa::createDHARMa(
  simulatedResponse =  simulate(fit, nsim = 500),
  observedResponse = dat$N, # true observations
  fittedPredictedResponse = fit$family$linkinv(predict(fit)$est_non_rf) # predicted response
)


# simulate from the model
sim_fit =  simulate(fit, nsim = 500)

#test whether fitted models are consistent with the observed number of zeros
sum(dat$N == 0) / length(dat$N)
sum(sim_fit == 0)/length(sim_fit)

```

- DHARMA plots

```{r}
plot(fit_dharma)

DHARMa::testResiduals(fit_dharma)

DHARMa::testZeroInflation(fit_dharma)

#DHARMa::testSpatialAutocorrelation(fit_dharma, x = dat$x, y = dat$y)

DHARMa::plotResiduals(fit_dharma, form = dat$depth)

```

## Predicting over the survey domain and calculating an index of abundance

To calculate an index of abundance, first we need to create a grid that covers the entirety of our survey domain. 

```{r}
library(tidyverse)
grid_dat <- tidyr::expand_grid(x = sort(unique(df_sim$x)), y = sort(unique(df_sim$y)))
grid_dat <- purrr::map_dfr(sort(unique(dat$year)), ~ bind_cols(grid_dat, year = .))
grid_dat$offset <- mean(dat$offset)
```
Next we need to predict from our model onto our survey grid. `return_tmb_object = TRUE` tells the function to return a TMB object that is critical for calculating the survey index. If enabled, the result will be a list with the predictions as one element and the TMB object as another. If disabled, the result will just be a prediction data frame.

The `area` argument represents the area of a grid cell so that the resulting estimate is per m^2^ or km^2^. Here, that is cell_area/tow_area.

```{r, eval=FALSE}

tow_area <- survey$setdet$tow_area[1] #cell and tow area is consistent in the simulation
cell_area <- survey$setdet$cell_area[1]


pred <- predict(fit, 
                newdata = grid_dat, 
                return_tmb_object = TRUE, #important for calculating the survey index
                area = cell_area/tow_area)  #cell_area/tow_area

index <- get_index(pred) #It sums up the abundance in all of the grid cells and calculates standard errors on the result
```

Let's make some graphs:

```{r}
#Total N estimates:
  
ggplot(index, aes(year, est)) + geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) +
  xlab('Year') + ylab('N')

```

# Combining Design-based and Model-based estimated indices with the "true" known population trajectory

```{r}
true_abund <- tibble(year = unique(df_sim$year), N = as.numeric(colSums(survey$I))) %>%
  mutate(type = "True")

strat_abund <- tibble::as_tibble(survey$total_strat) %>% 
  mutate(N = total, type = "Design-based") %>% 
  select(year, N, type)

index <- index %>%
  mutate(type = "Model-based", N = est) %>%
  bind_rows(true_abund) %>%
  bind_rows(strat_abund)

```

And make a plot of the result:

```{r}
ggplot(index, aes(year, N, group = type)) +
  geom_line(aes(colour = type, size = type)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.3) +
  labs(x = "Year", y = "N", colour = "Type", fill = "Type", size = "Type") +
  scale_color_manual(values = c("Model-based" = "grey30", "Design-based" = "steelblue", "True" = "red")) +
  scale_fill_manual(values = c("Model-based" = "grey30", "Design-based" = "steelblue", "True" = "red")) +
  scale_size_manual(values = c("Model-based" = 0.5, "Design-based" = 0.5, "True" = 1))
```
```{r}
index %>% 
  plot_ly(x = ~year, color = ~type, legendgroup = ~type) %>% 
  add_ribbons(ymin = ~lwr, ymax = ~upr, line = list(width = 0), showlegend = FALSE) %>% 
  add_lines(y = ~N)
```
